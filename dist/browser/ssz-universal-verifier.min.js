(function(global) {
  'use strict';

  // Minimal browser bundle for SSZ Universal Verifier
  // Includes: types, hash, parser, chunker, merkle, index
  // No external dependencies.

  const exports = {};

  // --- src/types.ts ---
  const TypeKind = {
    Basic: 0,
    Vector: 1,
    List: 2,
    Container: 3,
    Bitlist: 4
  };
  const SszError = {
    None: 0,
    BadOffset: 1,
    NonCanonical: 2,
    BitlistPadding: 3,
    UnsupportedType: 4,
    MalformedHeader: 5,
    LengthOverflow: 6,
    UnexpectedEOF: 7
  };

  // --- src/hash.ts ---
  function hashLeaf(chunk32) {
    return sha256(chunk32);
  }
  function hashParent(left32, right32) {
    const combined = new Uint8Array(64);
    combined.set(left32, 0);
    combined.set(right32, 32);
    return sha256(combined);
  }
  function sha256(data) {
    const K = [
      0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
      0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
      0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
      0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
      0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
      0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
      0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
      0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
    ];
    const len = data.length;
    const bitLen = len * 8;
    const padLen = len + 1 + ((119 - len) % 64);
    const totalLen = padLen + 8;
    const padded = new Uint8Array(totalLen);
    padded.set(data, 0);
    padded[len] = 0x80;
    for (let i = 0; i < 8; i++) {
      padded[totalLen - 1 - i] = (bitLen >>> (i * 8)) & 0xff;
    }
    let h0 = 0x6a09e667, h1 = 0xbb67ae85, h2 = 0x3c6ef372, h3 = 0xa54ff53a;
    let h4 = 0x510e527f, h5 = 0x9b05688c, h6 = 0x1f83d9ab, h7 = 0x5be0cd19;
    const W = new Uint32Array(64);
    for (let offset = 0; offset < totalLen; offset += 64) {
      for (let i = 0; i < 16; i++) {
        W[i] = (padded[offset + i * 4] << 24) | (padded[offset + i * 4 + 1] << 16) |
               (padded[offset + i * 4 + 2] << 8) | padded[offset + i * 4 + 3];
      }
      for (let i = 16; i < 64; i++) {
        const s0 = rotr(W[i - 15], 7) ^ rotr(W[i - 15], 18) ^ (W[i - 15] >>> 3);
        const s1 = rotr(W[i - 2], 17) ^ rotr(W[i - 2], 19) ^ (W[i - 2] >>> 10);
        W[i] = (W[i - 16] + s0 + W[i - 7] + s1) >>> 0;
      }
      let a = h0, b = h1, c = h2, d = h3, e = h4, f = h5, g = h6, h = h7;
      for (let i = 0; i < 64; i++) {
        const S1 = rotr(e, 6) ^ rotr(e, 11) ^ rotr(e, 25);
        const ch = (e & f) ^ (~e & g);
        const temp1 = (h + S1 + ch + K[i] + W[i]) >>> 0;
        const S0 = rotr(a, 2) ^ rotr(a, 13) ^ rotr(a, 22);
        const maj = (a & b) ^ (a & c) ^ (b & c);
        const temp2 = (S0 + maj) >>> 0;
        h = g; g = f; f = e; e = (d + temp1) >>> 0;
        d = c; c = b; b = a; a = (temp1 + temp2) >>> 0;
      }
      h0 = (h0 + a) >>> 0; h1 = (h1 + b) >>> 0; h2 = (h2 + c) >>> 0; h3 = (h3 + d) >>> 0;
      h4 = (h4 + e) >>> 0; h5 = (h5 + f) >>> 0; h6 = (h6 + g) >>> 0; h7 = (h7 + h) >>> 0;
    }
    const result = new Uint8Array(32);
    const view = new DataView(result.buffer);
    view.setUint32(0, h0, false); view.setUint32(4, h1, false);
    view.setUint32(8, h2, false); view.setUint32(12, h3, false);
    view.setUint32(16, h4, false); view.setUint32(20, h5, false);
    view.setUint32(24, h6, false); view.setUint32(28, h7, false);
    return result;
  }
  function rotr(n, b) {
    return (n >>> b) | (n << (32 - b));
  }

  // --- src/sszParser.ts ---
  function parseToRanges(td, bytes) {
    if (td.kind === TypeKind.Basic) {
      if (td.fixedSize === undefined) return { ranges: [], error: SszError.UnsupportedType, msg: 'Basic type missing fixedSize' };
      if (td.fixedSize === 0) {
        return { ranges: [{ start: 0, end: bytes.length }], error: SszError.None, msg: '' };
      }
      if (bytes.length !== td.fixedSize) return { ranges: [], error: SszError.NonCanonical, msg: 'Basic type length mismatch' };
      return { ranges: [{ start: 0, end: bytes.length }], error: SszError.None, msg: '' };
    }
    if (td.kind === TypeKind.Bitlist) {
      if (bytes.length === 0) return { ranges: [], error: SszError.NonCanonical, msg: 'Bitlist empty' };
      const lastByte = bytes[bytes.length - 1];
      if (lastByte === 0) return { ranges: [], error: SszError.BitlistPadding, msg: 'Bitlist sentinel missing' };
      let bitLen = (bytes.length - 1) * 8;
      let sentinel = lastByte;
      while (sentinel > 1) { bitLen++; sentinel >>= 1; }
      const paddingBits = (bytes.length * 8) - bitLen - 1;
      const mask = (1 << paddingBits) - 1;
      if ((lastByte & mask) !== 0) return { ranges: [], error: SszError.BitlistPadding, msg: 'Bitlist padding non-zero' };
      return { ranges: [{ start: 0, end: bytes.length }], error: SszError.None, msg: '' };
    }
    if (td.kind === TypeKind.List || td.kind === TypeKind.Vector) {
      if (!td.elementType) return { ranges: [], error: SszError.UnsupportedType, msg: 'List/Vector missing elementType' };
      const eleFixed = td.elementType.fixedSize;
      if (eleFixed !== undefined && eleFixed > 0) {
        const count = bytes.length / eleFixed;
        if (!Number.isInteger(count)) return { ranges: [], error: SszError.NonCanonical, msg: 'List fixed-size element misalignment' };
        const ranges = [];
        for (let i = 0; i < count; i++) {
          ranges.push({ start: i * eleFixed, end: (i + 1) * eleFixed });
        }
        return { ranges, error: SszError.None, msg: '' };
      } else {
        return parseVariableList(bytes);
      }
    }
    if (td.kind === TypeKind.Container) {
      if (!td.fieldTypes || td.fieldTypes.length === 0) return { ranges: [{ start: 0, end: bytes.length }], error: SszError.None, msg: '' };
      const fixedFields = td.fieldTypes.map(ft => ft.fixedSize !== undefined && ft.fixedSize > 0);
      const varCount = fixedFields.filter(f => !f).length;
      if (varCount === 0) {
        let totalFixedSize = 0;
        for (const ft of td.fieldTypes) totalFixedSize += ft.fixedSize;
        if (bytes.length !== totalFixedSize) return { ranges: [], error: SszError.MalformedHeader, msg: 'Container length mismatch' };
        let offset = 0;
        const ranges = [];
        for (const ft of td.fieldTypes) {
          const size = ft.fixedSize;
          ranges.push({ start: offset, end: offset + size });
          offset += size;
        }
        if (offset !== bytes.length) return { ranges: [], error: SszError.NonCanonical, msg: 'Container trailing bytes' };
        return { ranges, error: SszError.None, msg: '' };
      } else {
        return parseVariableContainer(td, bytes, fixedFields);
      }
    }
    return { ranges: [], error: SszError.UnsupportedType, msg: 'Unknown TypeKind' };
  }
  function parseVariableList(bytes) {
    if (bytes.length < 4) return { ranges: [], error: SszError.MalformedHeader, msg: 'Variable list too short for offsets' };
    const offsets = [];
    let i = 0;
    while (i + 4 <= bytes.length) {
      const off = readU32LE(bytes, i);
      if (off < i + 4) break;
      offsets.push(off);
      i += 4;
    }
    if (offsets.length === 0) return { ranges: [], error: SszError.MalformedHeader, msg: 'No offsets found' };
    const headerEnd = offsets[0];
    if (headerEnd !== offsets.length * 4) return { ranges: [], error: SszError.BadOffset, msg: 'Offset table misalignment' };
    for (let j = 1; j < offsets.length; j++) {
      if (offsets[j] <= offsets[j - 1]) return { ranges: [], error: SszError.BadOffset, msg: 'Offsets not strictly increasing' };
    }
    if (offsets[offsets.length - 1] > bytes.length) return { ranges: [], error: SszError.LengthOverflow, msg: 'Offset beyond buffer' };
    if (offsets[offsets.length - 1] !== bytes.length) return { ranges: [], error: SszError.NonCanonical, msg: 'Trailing bytes in list' };
    const ranges = [];
    for (let j = 0; j < offsets.length; j++) {
      const start = offsets[j];
      const end = j + 1 < offsets.length ? offsets[j + 1] : bytes.length;
      ranges.push({ start, end });
    }
    return { ranges, error: SszError.None, msg: '' };
  }
  function parseVariableContainer(td, bytes, fixedFields) {
    const fieldCount = fixedFields.length;
    let fixedSize = 0;
    let varCount = 0;
    for (let i = 0; i < fieldCount; i++) {
      if (fixedFields[i]) {
        fixedSize += td.fieldTypes[i].fixedSize;
      } else {
        fixedSize += 4;
        varCount++;
      }
    }
    if (bytes.length < fixedSize) return { ranges: [], error: SszError.MalformedHeader, msg: 'Container too short' };
    const offsets = [];
    let byteOffset = 0;
    for (let i = 0; i < fieldCount; i++) {
      if (fixedFields[i]) {
        byteOffset += td.fieldTypes[i].fixedSize;
      } else {
        const off = readU32LE(bytes, byteOffset);
        offsets.push(off);
        byteOffset += 4;
      }
    }
    const headerEnd = fixedSize;
    for (const off of offsets) {
      if (off < headerEnd) return { ranges: [], error: SszError.BadOffset, msg: 'Offset points into header' };
      if (off > bytes.length) return { ranges: [], error: SszError.LengthOverflow, msg: 'Offset beyond buffer' };
    }
    for (let i = 1; i < offsets.length; i++) {
      if (offsets[i] <= offsets[i - 1]) return { ranges: [], error: SszError.BadOffset, msg: 'Offsets not strictly increasing' };
    }
    const ranges = [];
    let fixedOff = 0;
    let varIdx = 0;
    for (let i = 0; i < fieldCount; i++) {
      if (fixedFields[i]) {
        const size = td.fieldTypes[i].fixedSize;
        ranges.push({ start: fixedOff, end: fixedOff + size });
        fixedOff += size;
      } else {
        fixedOff += 4;
        const start = offsets[varIdx];
        const end = varIdx + 1 < offsets.length ? offsets[varIdx + 1] : bytes.length;
        ranges.push({ start, end });
        varIdx++;
      }
    }
    return { ranges, error: SszError.None, msg: '' };
  }
  function readU32LE(bytes, offset) {
    return bytes[offset] | (bytes[offset + 1] << 8) | (bytes[offset + 2] << 16) | (bytes[offset + 3] << 24);
  }

  // --- src/chunker.ts ---
  function* streamChunksFromSlice(bytes, ranges) {
    for (const range of ranges) {
      const len = range.end - range.start;
      let offset = range.start;
      while (offset < range.end) {
        const chunk = new Uint8Array(32);
        const remain = range.end - offset;
        const toCopy = Math.min(32, remain);
        chunk.set(bytes.subarray(offset, offset + toCopy), 0);
        yield chunk;
        offset += 32;
      }
    }
  }
  function* streamChunksFromReader(reader, ranges) {
    const tempBuf = new Uint8Array(4096);
    let tempOffset = 0;
    let tempLen = 0;
    for (const range of ranges) {
      const rangeLen = range.end - range.start;
      let consumed = 0;
      while (consumed < rangeLen) {
        if (tempOffset >= tempLen) {
          tempOffset = 0;
          tempLen = reader(tempBuf);
          if (tempLen === 0) {
            yield { error: SszError.UnexpectedEOF, msg: 'Reader EOF mid-range' };
            return;
          }
        }
        const chunk = new Uint8Array(32);
        let chunkOffset = 0;
        const needForChunk = Math.min(32, rangeLen - consumed);
        while (chunkOffset < needForChunk && tempOffset < tempLen) {
          const avail = tempLen - tempOffset;
          const copy = Math.min(needForChunk - chunkOffset, avail);
          chunk.set(tempBuf.subarray(tempOffset, tempOffset + copy), chunkOffset);
          chunkOffset += copy;
          tempOffset += copy;
          consumed += copy;
        }
        if (chunkOffset < needForChunk && tempOffset >= tempLen) {
          tempOffset = 0;
          tempLen = reader(tempBuf);
          if (tempLen === 0) {
            yield { error: SszError.UnexpectedEOF, msg: 'Reader EOF within chunk' };
            return;
          }
        }
        yield chunk;
      }
    }
  }

  // --- src/merkle.ts ---
  function computeRootFromChunks(chunkGen, mixinLength) {
    const stack = [];
    let count = 0;
    for (const item of chunkGen) {
      if ('error' in item) return item;
      pushAndMerge(stack, { hash: item, height: 0 });
      count++;
    }
    if (stack.length === 0) {
      const zeroHash = new Uint8Array(32);
      if (mixinLength !== undefined) return { root: mixinLengthRoot(zeroHash, mixinLength) };
      return { root: zeroHash };
    }
    while (stack.length > 1) {
      const right = stack.pop();
      const left = stack.pop();
      const parent = hashParent(left.hash, right.hash);
      pushAndMerge(stack, { hash: parent, height: Math.max(left.height, right.height) + 1 });
    }
    let root = stack[0].hash;
    if (mixinLength !== undefined) {
      root = mixinLengthRoot(root, mixinLength);
    }
    return { root };
  }
  function pushAndMerge(stack, entry) {
    stack.push(entry);
    while (stack.length >= 2) {
      const top = stack[stack.length - 1];
      const below = stack[stack.length - 2];
      if (below.height !== top.height) break;
      stack.pop();
      stack.pop();
      const parent = hashParent(below.hash, top.hash);
      stack.push({ hash: parent, height: below.height + 1 });
    }
  }
  function mixinLengthRoot(root, length) {
    const lengthBuf = new Uint8Array(32);
    lengthBuf[0] = length & 0xff;
    lengthBuf[1] = (length >>> 8) & 0xff;
    lengthBuf[2] = (length >>> 16) & 0xff;
    lengthBuf[3] = (length >>> 24) & 0xff;
    return hashParent(root, lengthBuf);
  }

  // --- src/index.ts ---
  function sszStreamRootFromSlice(td, bytes) {
    const parsed = parseToRanges(td, bytes);
    if (parsed.error !== SszError.None) return { error: parsed.error, msg: parsed.msg };
    const chunkGen = streamChunksFromSlice(bytes, parsed.ranges);
    let mixinLength = undefined;
    if (td.kind === TypeKind.List) {
      mixinLength = parsed.ranges.length;
    } else if (td.kind === TypeKind.Bitlist && bytes.length > 0) {
      const lastByte = bytes[bytes.length - 1];
      let bitLen = (bytes.length - 1) * 8;
      let sentinel = lastByte;
      while (sentinel > 1) { bitLen++; sentinel >>= 1; }
      mixinLength = bitLen;
    }
    return computeRootFromChunks(chunkGen, mixinLength);
  }
  function sszStreamRootFromReader(td, reader) {
    const tempBuf = new Uint8Array(8192);
    let allBytes = new Uint8Array(0);
    while (true) {
      const n = reader(tempBuf);
      if (n === 0) break;
      const newAll = new Uint8Array(allBytes.length + n);
      newAll.set(allBytes, 0);
      newAll.set(tempBuf.subarray(0, n), allBytes.length);
      allBytes = newAll;
    }
    return sszStreamRootFromSlice(td, allBytes);
  }

  exports.TypeKind = TypeKind;
  exports.SszError = SszError;
  exports.sszStreamRootFromSlice = sszStreamRootFromSlice;
  exports.sszStreamRootFromReader = sszStreamRootFromReader;

  global.SSZ = exports;

})(typeof window !== 'undefined' ? window : this);
